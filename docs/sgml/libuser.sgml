<!doctype linuxdoc system>
<article>

<title>libuser 0.5</title>
<author>Nalin Dahyabhai <tt/&lt;nalin@redhat.com&gt;/
<date>2 January 2001
<abstract>This is the libuser administrator and programmer's guide.  It
first describes the motivation for the existence of this library, and
then delves into the library interface used by both libuser modules and
applications.</abstract>

<sect>Introduction

<p>This section describes libuser: why it was written, and how it works.  How
the library is to be used will be described later.

<sect1>Motivation

<p>When proper nsswitch functionality was introduced into glibc 2.0, it
became possible to supply third-party facilities which would allow the
standard C library (and by extension, all of a system's binaries) to pull
information about users, protocols, and services from a variety of sources
the glibc authors might not have anticipated.

<p>The most common use for a new nsswitch module is supplementing the user
and group databases, extending the data sources accessed over a network
to a centrally-managed information store.  This, along with the ability to
authenticate users using networked servers (functionality provided by the
increasingly-ubiquitous Linux-PAM library) and an enterprise-class
networked filesystem, allows a properly-configured Linux workstation to
participate as a full-fledged client in a large-scale network.

<p>The facilities provided by PAM allow a user to log in and change her
authentication tokens.  The nsswitch interface allows any user (even
unprivileged users like <bf>nobody</bf>) to look up information needed
to run applications.

<p>However, there are certain functions supplied by traditional isolated
systems which such a networked workstation can't provide.  Users have no
method for modifying their information (<bf>chfn</bf> is broken), and the
system administrator who previously had total power over the user and
group databases must now perform all administration at the server using
tools which are designed for general modification of the information
store (hand-editing zone files for hesiod databases, <bf>ldapmodify</bf>,
<bf>kadmin</bf>) instead of the traditionally-used tools.

</sect1>

<sect1>Alternative Solutions

<p>The software which comes closest to meeting these needs is
<bf>pwdb</bf>.  However, the pwdb library has a few design limitations
which make it unsuitable for this purpose.  Like the standard files-based
mechanisms, pwdb assumes that the superuser wields full access over the
databases it interfaces with.  The current version of pwdb provides no
facilities for managing groups.  The current version of pwdb can not be
extended easily by third parties due to its reliance on static linking.

</sect1>

<sect1>The libuser Library

<p>The libuser library implements a fully-modular system for reading,
modifying, creating, and removing user and group accounts and account
information.  Modules which provide access to information stores can
request information from the accessing user in order to authenticate to
the information store.  

</sect1>

</sect>

<sect>System Administration

<p>This section describes libuser's configuration file and bundled
applications which may be of use to system administrators.

<sect1>Configuration

<p>The libuser configuration file is named <bf>libuser.conf</bf> and
usually lives in <bf>/etc</bf>.  Its format is the common format used
by numerous other programs.  Sections are marked by the section name
enclosed in square brackets (<bf>[section]</bf>), and configuration
directives within these sections are of the form <bf>key = value</bf>.

<p>The <bf>defaults</bf>, <bf>userdefaults</bf>, and <bf>groupdefaults</bf>
sections are used by the library itself.  The <bf>defaults</bf> section
specifies the directory where modules can be found and lists the modules
to be consulted when looking up user information.

</sect1>

<sect1>Modules

<p>Specific modules implement access to specific information stores.  The
modules included in the source distribution are the <bf>files</bf> and
<bf>shadow</bf> modules.  Modules can supply and manipulate either (or both)
of two distinct types of data about a user: generic user information (the
UID, home directory, etc.), and authentication-related information.

<sect2>files

<p>The files module implements both information and authentication data
stores using the standard <bf>passwd</bf> and <bf>group</bf> files.

<p>This module uses the <bf>files</bf> section of the configuration file
to store configuration data.  It presently recognizes these flags:

<itemize>
<item>directory - the directory the <bf>passwd</bf> and <bf>group</bf> files
are to be stored in
</itemize>

</sect2>

<sect2>shadow

<p>The shadow module implements only an authentication data store using
the <bf>shadow</bf> and the <bf>gshadow</bf> files.  While the format of
these files (and even the existence of the <bf>gshadow</bf> file) varies
between OSs, this module supports the same file formats used by the shadow
password suite.

<p>This module uses the <bf>shadow</bf> section of the configuration file
to store configuration data.  It presently recognizes these flags:

<itemize>
<item>directory - the directory the <bf>shadow</bf> and <bf>gshadow</bf>
files are to be stored in.
</itemize>
</sect2>

<sect2>krb5

<p>The krb5 module implements only an authentication data store using
a connection to the Kerberos realm's administrative server.

</sect2>

</sect1>

<sect1>Applications

<p>Sample testbed applications which mimic the behavior of certain parts
of the shadow password suite are included in the libuser distribution.
To allow them to be used alongside existing utilities, their names have
been prefixed with the letter 'l'.

<p>As of this writing (version 0.4), this list of tools includes
workalikes for <bf>useradd</bf>, <bf>usermod</bf>, <bf>userdel</bf>,
<bf>groupadd</bf>, <bf>groupmod</bf>, <bf>groupdel</bf>, and <bf>chage</bf>.
It should be noted that none of these tools provide a means for modifying
the defaults they use, and no functions for creating, populating, moving, or
deleting user home directories are implemented.

</sect1>

</sect>

<sect>The Application Interface

<p>This section describes the public libuser API, which is available to
applications.

<sect1>Initialization and Termination

<p>This section describes how to start up and shut down the library.

<itemize>
<item>struct lu_context* lu_start(const char *auth_user, enum lu_type auth_type, const char *info_modules, const char *auth_modules, lu_prompt_fn *prompter, gpointer callback_data)
<p>Initializes the library, loads the specified modules, and returns a
context structure on success, or <bf>NULL</bf> on failure.
<p>The <bf>auth_user</bf> and <bf>auth_name</bf> arguments are hints to
the modules for determining the identity to connect to information stores as.
The default administrator can be specified by passing in <bf>NULL</bf> as the
<bf>auth_user</bf> argument.
<p>The <bf>info_modules</bf> and <bf>auth_modules</bf> arguments allow the
application to override the lists of modules set in the library's configuration
file.  The application can specify <bf>NULL</bf> for both values to use the
configured defaults.
<p>The <bf>prompter</bf> argument is the address of a function which modules can
call in order to obtain information needed for accessing information stores.
The library provides <bf>lu_prompt_console</bf> for console-based applications.
If the application passes in <bf>NULL</bf>, then no prompts will be made, and
library initialization may fail.
<p>The <bf>callback_data</bf> argument is a pointer to application-specific data
which the <bf>prompter</bf> function will be passed whenever it is called.

<item>void lu_set_info_modules(struct lu_context *context, const char *list)
<p>Sets the list of information modules used.  The <bf>context</bf> argument
is a structure obtained through a previous call to <bf>lu_start</bf>, and the
<bf>list</bf> argument is identical to the <bf>info_modules</bf> argument
used by <bf>lu_start</bf>.

<item>void lu_set_auth_modules(struct lu_context *context, const char *list)
<p>Sets the list of authentication modules used.  The <bf>context</bf> argument
is a structure obtained through a previous call to <bf>lu_start</bf>, and the
<bf>list</bf> argument is identical to the <bf>auth_modules</bf> argument
used by <bf>lu_start</bf>.

<item>void lu_end(struct lu_context *context)
<p>Shuts down the library, unloads the modules in use, and frees memory.

</itemize>

</sect1>

<sect1>Entity Structures

<p>This section describes the entity data structure and how it is used
to look up, create, modify, and destroy users and groups.

<itemize>

<item>struct lu_ent *lu_ent_new()

<p>Creates a new <bf>lu_ent</bf> structure.  This is an array of lists,
indexed by strings, of user/group attributes, similar to a pwdb_entry.
An <bf>lu_ent</bf> also contains a notion of <bf>original</bf> and
<bf>working</bf> attribute sets.

<item>void lu_ent_copy(struct lu_ent *source, struct lu_ent *dest)

<p>Copies the contents of one <bf>lu_ent</bf> to another.

<item>void lu_ent_revert(struct lu_ent *ent)

<p>Sets the <bf>lu_ent</bf>'s working attribute set to match the values stored
in its original attribute set.

<item>void lu_ent_free(struct lu_ent *ent)

<p>Frees an <bf>lu_ent</bf> structure.

<item>GList *lu_ent_get_attributes(struct lu_ent *ent)

<p>Returns a <bf>GList</bf> of the names of the attributes the entity has
defined values for.

<item>GList *lu_ent_get(struct lu_ent *ent, const char *attribute)

<p>Returns a <bf>GList</bf> of the values for the named attribute which the
entity structure contains.

<item>GList *lu_ent_get_original(struct lu_ent *ent, const char *attribute)

<p>Like <bf>lu_ent_get</bf>, but accesses the original attribute set instead
of the working attribute set.

<item>gboolean lu_ent_set(struct lu_ent *ent, const char *attr, const char *val)

<p>Most attributes only contain a single value.  This function can be used to
set that value.  Returns <bf>TRUE</bf> on success, and <bf>FALSE</bf> on
failure.

<item>gboolean lu_ent_set_original(struct lu_ent *ent, const char *attr,
                             const char *val)

<p>Like <bf>lu_ent_set</bf>, but access the original attribute set instead of
the working attribute set.  This is used when populating new structures and
creating accounts.

<item>gboolean lu_ent_add(struct lu_ent *ent, const char *attr, const char *val)

<p>Adds a value to the list of values for the named attribute.  Returns
<bf>TRUE</bf> on success, and <bf>FALSE</bf> on failure.

<item>gboolean lu_ent_add_original(struct lu_ent *ent, const char *attr,
                             const char *val)

<p>Like <bf>lu_ent_add</bf>, but accesses the original attribute set instead
of the working attribute set.

<item>gboolean lu_ent_del(struct lu_ent *ent, const char *attr, const char *val)

<p>Removes a value from the list of values for the named attribute.  Returns
<bf>TRUE</bf> on success, and <bf>FALSE</bf> on failure.

<item>gboolean lu_ent_clear(struct lu_ent *ent, const char *attr)

<p>Removes all values from the list of values for the named attribute, and
removes the attribute.  Returns <bf>TRUE</bf> on success, and <bf>FALSE</bf> on
failure.

<item>gboolean lu_ent_clear_original(struct lu_ent *ent, const char *attr)

<p>Like <bf>lu_ent_clear</bf>, but accesses the original attribute set instead
of the working attribute set.

</itemize>

</sect1>

<sect1>Manipulating Users and Groups

<p>This section describes how an application can look up user and group
information, and add, modify, and delete accounts.  Although the library
provides distinct user and group access functions, the function declarations
are similar enough that the group variants are omitted here.

<itemize>

<item>gboolean lu_user_lookup_name(struct lu_context *context, const char *name, struct lu_ent *ent)

<p>Looks up information for the named user, and stores the information in the
passed <bf>lu_ent</bf> structure if such information is found.  Returns
<bf>TRUE</bf> on success, <bf>FALSE</bf> on failure.

<item>gboolean lu_user_lookup_id(struct lu_context *context, uid_t uid, struct lu_ent *ent)

<p>Like <bf>lu_user_lookup_name</bf>, but takes a <bf>uid_t</bf> instead of a
name.  The group variant takes a <bf>gid_t</bf>.

<item>gboolean lu_user_add(struct lu_context *context, struct lu_ent *ent)

<p>Creates a new user account using information stored in the <bf>lu_ent</bf>
structure.  Returns <bf>TRUE</bf> if the operation is successful.  The library
does this by attempting to create an authentication entity for the user (this
is a purposefully vague description -- individual back-end modules will do this
in different ways) using one of the configured <bf>auth_modules</bf>.  If this
succeeds, the library will create a general information entity for the user
using one of the configured <bf>info_modules</bf>.

<item>gboolean lu_user_modify(struct lu_context *context, struct lu_ent *ent)

<p>Brings the user's account information (as reflected in information stores)
in line with the working attribute set in the passed-in <bf>lu_ent</bf>
structure.  Returns <bf>TRUE</bf> if the operation is successful, <bf>FALSE</bf>
if it fails.  The library keeps track of the information stores accessed for
the user's <bf>auth</bf> and <bf>info</bf> attributes, and modifies only these.

<item>gboolean lu_user_delete(struct lu_context *context, struct lu_ent *ent)

<p>Deletes the named user account from the information stores which contain
the user's <bf>auth</bf> and <bf>info</bf> attributes.  Returns <bf>TRUE</bf>
if the deletion operation is successful.

<item>gboolean lu_user_lock(struct lu_context *context, struct lu_ent *ent)

<p>Locks the account of the user who was passed in.
Returns <bf>TRUE</bf> if the locking operation is successful, or <bf>FALSE</bf>
if the locking fails (for example, if the account is already locked or if
account locking is not supported by the <bf>auth</bf> information store).

<item>gboolean lu_user_unlock(struct lu_context *context, struct lu_ent *ent)

<p>Unlocks the account of the user who was passed in.
Returns <bf>TRUE</bf> if the unlocking operation is successful or <bf>FALSE</bf>
if the account was not locked or could not be unlocked.

</itemize>

</sect1>

<sect1>Reading the Configuration

<p>This section describes the mechanism libuser provides for applications
and modules to access configuration data.

<itemize>

<item>GList *lu_cfg_read(struct lu_context *context, const char *key, const char *default_value)

<p>Reads the contents of a particular key in the configuration file, and
returns a <bf>GList</bf> of the results.  The key is of the form
&quot;<bf>section</bf>/<bf>key</bf>&quot;.  An example key is &quot;defaults/moduledir&quot;.  If no matches are found, a list containing <bf>default_value</bf>
will be returned.

<item>GList *lu_cfg_read_keys(struct lu_context *context, const char *parent_key)

<p>Reads and returns a list of the keys within the section named by
the <bf>parent_key</bf>.  This function is useful for iterating over an
entire section of the configuration file.

</itemize>

</sect1>

</sect>

</article>
